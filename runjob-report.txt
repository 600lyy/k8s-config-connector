## Analysis of HTTP Log Differences: Direct vs. Terraform-based RunJob Controllers

This report details the differences in HTTP traffic generated by the direct controller and the Terraform-based (TF) controller when managing a `RunJob` resource. The analysis is based on a comparison of their respective `_http.log` files.

### Summary of Key Differences

1.  **Enum Value Encoding**: The direct controller sends API enum values as integers, while the TF-based controller sends them as strings.
2.  **Create Request (`POST`) Payload**: The direct controller sends a minimal payload containing only user-specified fields. The TF-based controller includes some default values in its create request.
3.  **Update Request (`PATCH`) Payload**: The direct controller sends a precise, minimal payload containing only the fields that have changed. The TF-based controller sends a full payload that includes many unchanged, server-defaulted fields.

---

### Detailed Request-by-Request Breakdown

#### 1. Initial `GET` Request (Existence Check)

-   **Direct Controller**: `GET .../jobs/${jobID}?%24alt=json%3Benum-encoding%3Dint`
-   **TF-based Controller**: `GET .../jobs/${jobID}?alt=json`

**Analysis**: The only difference is the `enum-encoding=int` query parameter used by the direct controller. This is a client-side preference that requests enum values (like `launchStage`) be returned as integers instead of strings. It does not affect the fundamental logic, as both controllers correctly receive a `404 Not Found` and proceed to create the resource.

---

#### 2. `POST` Request (Resource Creation)

-   **Direct Controller Request Body**:
    ```json
    {
      "launchStage": 4,
      "template": { ... }
    }
    ```
-   **TF-based Controller Request Body**:
    ```json
    {
      "launchStage": "GA",
      "template": {
        "template": {
          ...,
          "maxRetries": 3
        }
      }
    }
    ```

**Analysis**:
-   **`launchStage`**: The direct controller sends the integer `4` (due to `enum-encoding=int`), while the TF controller sends the string `"GA"`.
-   **`maxRetries`**: The TF-based controller explicitly includes `"maxRetries": 3`, which is the default value for this field. The direct controller omits this, relying on the API server to apply the default. This demonstrates the direct controller's principle of only sending fields that are explicitly configured in the user's YAML manifest.

---

#### 3. `PATCH` Request (Resource Update)

This is the most significant point of divergence, highlighting the different operational strategies of the two controllers.

-   **Direct Controller Request Body**:
    ```json
    {
      "launchStage": 4,
      "name": "projects/.../jobs/runjob-${uniqueId}",
      "template": {
        "template": {
          "containers": [{
            "image": "us-docker.pkg.dev/cloudrun/container/hello",
            "name": "container-name"
          }]
        }
      }
    }
    ```
-   **TF-based Controller Request Body**:
    ```json
    {
      "launchStage": "GA",
      "template": {
        "taskCount": 1,
        "template": {
          "containers": [{
            "image": "us-docker.pkg.dev/cloudrun/container/hello",
            "name": "container-name",
            "resources": { ... }
          }],
          "executionEnvironment": "EXECUTION_ENVIRONMENT_GEN2",
          "maxRetries": 3,
          "serviceAccount": "...",
          "timeout": "600s"
        }
      }
    }
    ```

**Analysis**:
-   **Payload Size and Precision**: The direct controller's `PATCH` body is minimal. It correctly identifies that only the container's `name` was added and sends a request to update just that part of the resource.
-   **State Management**: The TF-based controller's `PATCH` body is much larger. After creating the resource, it reads the *entire* state, including server-defaulted fields like `taskCount`, `resources`, `serviceAccount`, and `timeout`. It then includes all of these fields in the update request, even though they were not modified by the user. This reflects Terraform's model of enforcing the complete state of a resource on every update.

---

### Conclusion

The direct controller operates more efficiently and precisely. By performing a diff between the desired user configuration and the live state of the GCP resource, it generates minimal `PATCH` requests that target only the fields that have actually changed.

The TF-based controller, in contrast, manages the resource as a whole block of state. This leads to larger update payloads that include server-generated and default values, which is less efficient from a network perspective but is consistent with Terraform's underlying state management philosophy.
