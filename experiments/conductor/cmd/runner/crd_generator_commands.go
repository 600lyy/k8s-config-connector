// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package runner

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// NOT USED
/*
const GENERATOR_SCRIPT_TEMPLATE = `#!/bin/bash
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd ${REPO_ROOT}/dev/tools/controllerbuilder

go run . generate-types \
    --service <PROTO_PACKAGE> \
    --api-version <CRD_GROUP>/<CRD_VERSION> \
    --resource <CRD_KIND>:<PROTO_RESOURCE>

go run . generate-mapper \
    --service <PROTO_PACKAGE> \
    --api-version <CRD_GROUP>/<CRD_VERSION>

cd ${REPO_ROOT}
dev/tasks/generate-crds

go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/<SERVICE>/
`

// NOT USED
const UPDATE_GENERATE_SCRIPT_PROMPT = `
Please update the apis/<SERVICE>/v1alpha1/generate.sh script for the <SERVICE> API to generate the CRD for the <CRD_KIND> resource.

The generate.sh script is located at apis/<SERVICE>/v1alpha1/generate.sh.

Add the parameter <TICK> --resource <CRD_KIND>:<PROTO_RESOURCE><TICK> to the <TICK>go run . generate-types --api-version <CRD_GROUP>/<CRD_VERSION>  <TICK> command.

At the end of the script, ensure the following lines are present:

cd ${REPO_ROOT}
dev/tasks/generate-crds

go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/<SERVICE>/
`

// NOT USED
func generateCRDFromScripts(opts *RunnerOptions, branch Branch) {
	close := setLoggingWriter(opts, branch)
	defer close()
	workDir := opts.branchRepoDir

	var out strings.Builder
	checkoutBranch(branch, workDir, &out)

	// Create the apis/<service>/<version> directory
	serviceDir := filepath.Join(workDir, "apis", branch.Group, "v1alpha1")
	if err := os.MkdirAll(serviceDir, 0755); err != nil {
		log.Fatal(err)
	}

	// Create or update generate.sh
	scriptPath := filepath.Join(serviceDir, "generate.sh")
	// Check if generate.sh already exists.
	if _, err := os.Stat(scriptPath); errors.Is(err, os.ErrNotExist) {
		// File doesn't exist, use template approach
		log.Printf("Creating new generate.sh at %s", scriptPath)

		// Replace template markers with actual values and write to file
		writeTemplateToFile(branch, scriptPath, GENERATOR_SCRIPT_TEMPLATE)
	} else {
		// File exists, use codebot to update it
		log.Printf("Updating existing generate.sh at %s", scriptPath)

		// Delete then write the prompt file.
		promptPath := filepath.Join(workDir, "mockgcp", "crdgen_prompt.txt")
		writeTemplateToFile(branch, promptPath, UPDATE_GENERATE_SCRIPT_PROMPT)

		cfg := CommandConfig{
			Name:    "CODEBOT GENERATE",
			Cmd:     "codebot",
			Args:    []string{"--ui-type=prompt", "--prompt=mockgcp/crdgen_prompt.txt"},
			WorkDir: workDir,
		}
		if err := executeCommand(cfg, &out); err != nil {
			log.Fatal(err)
		}
	}

	// Stage the changed files
	scriptRelativePath := filepath.Join("apis", branch.Group, "v1alpha1", "generate.sh")
	gitAdd(workDir, &out, scriptRelativePath)

	// Commit the changes
	gitCommit(workDir, &out, fmt.Sprintf("add/update crd generation script for %s", branch.Group))

	// Run the generator script
	cfg := CommandConfig{
		Name:    "Generator script",
		Cmd:     scriptPath,
		WorkDir: workDir,
	}
	if err := executeCommand(cfg, &out); err != nil {
		log.Fatal(err)
	}

	// Stage the changed files
	gitAdd(workDir, &out,
		fmt.Sprintf("apis/%s/v1alpha1/", branch.Group),
		fmt.Sprintf("pkg/controller/direct/%s/", branch.Group),
		"config/crds/resources/")

	// Commit the changes
	gitCommit(workDir, &out, fmt.Sprintf("autogenerated types and CRDs using %s", scriptRelativePath))
}
*/

func generateTypes(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	// Check parameters
	if branch.Kind == "" || branch.Proto == "" || branch.Group == "" {
		if branch.Kind == "" {
			log.Printf("SKIPPING %s, missing Kind", branch.Name)
		}
		if branch.Proto == "" {
			log.Printf("SKIPPING %s, missing Proto", branch.Name)
		}
		if branch.Group == "" {
			log.Printf("SKIPPING %s, missing Group", branch.Name)
		}
		return nil, fmt.Errorf("missing required parameters")
	}

	// Generate types
	apiDirPathRelative := filepath.Join("apis", branch.Group, "v1alpha1", string(filepath.Separator))
	apiDirPath := filepath.Join(opts.branchRepoDir, apiDirPathRelative)
	if _, err := os.Stat(apiDirPath); errors.Is(err, os.ErrNotExist) || opts.force {
		cfg := CommandConfig{
			Name: "Generate types",
			Cmd:  "go",
			Args: []string{
				"run", ".",
				"generate-types",
				"--service", branch.Package,
				"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
				"--resource", fmt.Sprintf("%s:%s", branch.Kind, branch.Proto),
			},
			WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
			MaxAttempts: 1,
		}
		_, err := executeCommand(opts, cfg)
		if err != nil {
			return nil, fmt.Errorf("failed to generate types: %w", err)
		}
		return []string{apiDirPathRelative}, nil
	}

	log.Printf("SKIPPING generating apis, %s already exists", apiDirPathRelative)
	return nil, nil
}

func generateMapper(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	// Check parameters
	if branch.Kind == "" || branch.Proto == "" || branch.Group == "" {
		if branch.Kind == "" {
			log.Printf("SKIPPING %s, missing Kind", branch.Name)
		}
		if branch.Proto == "" {
			log.Printf("SKIPPING %s, missing Proto", branch.Name)
		}
		if branch.Group == "" {
			log.Printf("SKIPPING %s, missing Group", branch.Name)
		}
		return nil, fmt.Errorf("missing required parameters")
	}

	// Generate mapper
	mapperDirPathRelative := filepath.Join("pkg", "controller", "direct", branch.Group, string(filepath.Separator))
	mapperDirPath := filepath.Join(opts.branchRepoDir, mapperDirPathRelative)
	if _, err := os.Stat(mapperDirPath); errors.Is(err, os.ErrNotExist) || opts.force {
		cfg := CommandConfig{
			Name: "Generate mapper",
			Cmd:  "go",
			Args: []string{
				"run", ".",
				"generate-mapper",
				"--service", branch.Package,
				"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
			},
			WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
			MaxAttempts: 2,
		}
		_, err := executeCommand(opts, cfg)
		if err != nil {
			return nil, fmt.Errorf("failed to generate mapper: %w", err)
		}

		return []string{mapperDirPathRelative}, nil
	}

	log.Printf("SKIPPING generating mappers, %s already exists", mapperDirPathRelative)
	return nil, nil
}

func generateCRD(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	apiDirPathRelative := filepath.Join("apis", branch.Group, "v1alpha1", string(filepath.Separator))
	affectedPaths := []string{"config/crds/resources/", apiDirPathRelative}

	// Generate CRDs
	cfg := CommandConfig{
		Name:        "Generate CRDs",
		Cmd:         filepath.Join(opts.branchRepoDir, "dev", "tasks", "generate-crds"),
		WorkDir:     opts.branchRepoDir,
		MaxAttempts: 1,
	}

	_, err := executeCommand(opts, cfg)
	return affectedPaths, err
}

func generateSpecStatus(opts *RunnerOptions, branch Branch) ([]string, error) {
	affectedPaths := []string{
		filepath.Join("apis", branch.Group, "v1alpha1",
			fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource))),
	}

	// Run controllerbuilder to generate spec and status
	log.Printf("Generating spec and status for %s", branch.Name)
	stdinInput := fmt.Sprintf("// +kcc:proto=%s.%s\n", branch.ProtoSvc, branch.Proto)

	cfg := CommandConfig{
		Name: "Spec/Status generation",
		Cmd:  "controllerbuilder",
		Args: []string{
			"prompt",
			"--src-dir", opts.branchRepoDir,
			"--proto-dir", filepath.Join(opts.branchRepoDir, ".build", "third_party", "googleapis"),
		},
		WorkDir:      opts.branchRepoDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	_, err := executeCommand(opts, cfg)
	//commitMsg := fmt.Sprintf("Generated spec and status for %s", branch.Kind)
	return affectedPaths, err
}

func generateFuzzer(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	workDir := opts.branchRepoDir
	affectedPaths := []string{}

	// Generate fuzzer file
	fuzzerDir := filepath.Join(opts.branchRepoDir, "pkg", "controller", "direct", branch.Group)
	if err := os.MkdirAll(fuzzerDir, 0755); err != nil {
		return affectedPaths, fmt.Errorf("failed to create fuzzer directory: %w", err)
	}

	fuzzerPath := filepath.Join(fuzzerDir, fmt.Sprintf("%s_fuzzer.go", strings.ToLower(branch.Resource)))
	stdinInput := fmt.Sprintf(`// +tool:fuzz-gen
// proto.message: %s
`, branch.ProtoMsg)

	cfg := CommandConfig{
		Name:         "Fuzzer generation",
		Cmd:          "controllerbuilder",
		Args:         []string{"prompt", "--src-dir", workDir, "--proto-dir", filepath.Join(workDir, ".build", "third_party", "googleapis")},
		WorkDir:      workDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	output, err := executeCommand(opts, cfg)
	if err != nil {
		return affectedPaths, fmt.Errorf("failed to generate fuzzer: %w", err)
	}

	if err := os.WriteFile(fuzzerPath, []byte(output.Stdout), 0644); err != nil {
		return affectedPaths, fmt.Errorf("failed to write fuzzer file: %w", err)
	}

	affectedPaths = append(affectedPaths, fuzzerPath)

	// Update register.go to import the new package
	registerPath := filepath.Join(opts.branchRepoDir, "pkg", "controller", "direct", "register", "register.go")
	importLine := fmt.Sprintf(`_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/%s"`, branch.Group)
	stdinInput = fmt.Sprintf("Add an unnamed (_) go import for %s to the imports in %s", importLine, registerPath)

	cfg = CommandConfig{
		Name:         "Import addition",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		WorkDir:      workDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	_, err = executeCommand(opts, cfg)
	if err != nil {
		return affectedPaths, fmt.Errorf("failed to add import: %w", err)
	}

	affectedPaths = append(affectedPaths, registerPath)

	return affectedPaths, nil
}

const SET_TYPE_SPEC_STATUS string = `I need to set the Spec and Status fields in the generated KRM type ${KIND} to match the proto ${PROTO_RESOURCE} definition.

Given:
- Generated types file: ${GENERATED_TYPES_FILE}
- resource types files: ${RESOURCE_TYPES_FILES}
- Proto resource: ${PROTO_RESOURCE}

Main Objectives:
1. Copy only the Fields from the ${PROTO_RESOURCE} struct in ${GENERATED_TYPES_FILE} to the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
2. if ${PROTO_RESOURCE}ObservedState struct exists, copy the Fields from the ${PROTO_RESOURCE}ObservedState to the ${KIND}ObservedState struct in ${RESOURCE_TYPES_FILES}.
3. if ${PROTO_RESOURCE}ObservedState struct does not exist, remove the ${KIND}ObservedState struct from ${RESOURCE_TYPES_FILES}.
4. Dont copy any structs from ${GENERATED_TYPES_FILE} to ${RESOURCE_TYPES_FILES}.
5. Ensure that the ${KIND}Spec struct has the following fields:
- ResourceID *string <TICK>json:"resourceID,omitempty"<TICK>
6. Please do not modify the ${GENERATED_TYPES_FILE} file.
7. Please do not modify the ${IDENTITY_FILE} file.

Please ignore the compilation errors and dont verify or try to fix:
1. compilation error due to missing DeepCopy methods
2. Errors in the ${IDENTITY_FILE} file

Please update the ${RESOURCE_TYPES_FILES} file with the adjusted types.

Contents of ${GENERATED_TYPES_FILE}:
${GENERATED_TYPES_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

`

func setTypeSpecStatus(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	generatedTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, generatedTypesPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read generated types file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(SET_TYPE_SPEC_STATUS, "${GENERATED_TYPES_FILE}", string(generatedTypesPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${GENERATED_TYPES_FILE_CONTENTS}", string(generatedTypesContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Set spec and status",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	_, err = executeCommand(opts, cfg)
	return []string{resourceTypesPath}, err
}

const SET_TYPE_PARENT string = `I need to add a Parent struct in the generated ${KIND}Spec struct.

Given:
- Generated types file: ${GENERATED_TYPES_FILE}
- resource types files: ${RESOURCE_TYPES_FILES}
- Proto resource: ${PROTO_RESOURCE}
- Proto files: 
    ${PROTO_FILES}

Main Objectives:
1. Add the Parent field to the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
- Parent <TICK>json:",inline"<TICK>
2. Add the Parent struct before the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
3. Please do not modify the ${GENERATED_TYPES_FILE} file.
4. Please do not remove any other fields from the ${KIND}Spec struct.

Please ignore the compilation errors and dont verify or try to fix:
1. compilation error due to missing DeepCopy methods
2. Errors in the ${IDENTITY_FILE} file

Rules for generating the Parent struct:
1.  example Parent structs are:
type Parent struct {
	// +required
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +required
	Location string <TICK>json:"location"<TICK>
}

type Parent struct {
	// +required
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
}

type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef"<TICK>
}

2. Inspect the ${PROTO_FILES} to determine the fields for the Parent struct. 
3. Look for the multiple "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> to determine the parent fields

4. For example, if the multiple "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> are:
    <TICK>
    pattern: "projects/{project}/locations/{location}/quotaPreferences/{quota_preference}"
    pattern: "folders/{folder}/locations/{location}/quotaPreferences/{quota_preference}"
    pattern: "organizations/{organization}/locations/{location}/quotaPreferences/{quota_preference}"
    <TICK>
  would result in the following Parent struct:

type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef"<TICK>
}

5. refv1beta1 package comes from "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"

6. Please make sure there is only one import block in the ${RESOURCE_TYPES_FILES} file and it appears at the beginning of the file.

Please update the ${RESOURCE_TYPES_FILES} file with the adjusted types.

Contents of ${GENERATED_TYPES_FILE}:
${GENERATED_TYPES_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func setTypeParent(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	generatedTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, generatedTypesPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read generated types file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(SET_TYPE_PARENT, "${GENERATED_TYPES_FILE}", string(generatedTypesPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${GENERATED_TYPES_FILE_CONTENTS}", string(generatedTypesContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Set parent",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	_, err = executeCommand(opts, cfg)
	return []string{resourceTypesPath}, err
}

func regenerateTypes(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	// Regenerate types
	cfg := CommandConfig{
		Name: "Regenerate types",
		Cmd:  "go",
		Args: []string{
			"run", ".",
			"generate-types",
			"--service", branch.Package,
			"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
			"--resource", fmt.Sprintf("%s:%s", branch.Kind, branch.Proto),
		},
		WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
		MaxAttempts: 1,
	}
	_, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath, generatedTypesPath}, err
}

const ADJUST_IDENTITY_PARENT string = `I want you to update the ${PROTO_RESOURCE}Parent struct in the ${IDENTITY_FILE} file along with the String() method and the Parse${PROTO_RESOURCE}External method.

Main Objectives:
1. Modify the ${PROTO_RESOURCE}Parent struct in ${IDENTITY_FILE}.
2. Modify the ${PROTO_RESOURCE}Parent's String() method in ${IDENTITY_FILE}.
3. Modify the Parse${PROTO_RESOURCE}External method in ${IDENTITY_FILE}.
4. Please do not modify the ${RESOURCE_TYPES_FILES} file.
5. Please ignore the compilation errors due to missing DeepCopy methods
6. If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the ${PROTO_RESOURCE}Parent struct stating that no changes were needed.

Rules for modifying the ${PROTO_RESOURCE}Parent struct:
1.  example ${PROTO_RESOURCE}Parent structs are:

type ${PROTO_RESOURCE}Parent struct {
	ProjectID string
	Location  string
}

type ${PROTO_RESOURCE}Parent struct {
	OrganizationID string
	ProjectID      string
	Location       string
}

type ${PROTO_RESOURCE}Parent struct {
	OrganizationID string
	FolderID       string
	ProjectID      string
}

2. Inspect the Parent structs in the ${RESOURCE_TYPES_FILES} file to determine the fields for the ${PROTO_RESOURCE}Parent struct.
   For example, if the ${RESOURCE_TYPES_FILES} file has the following Parent structs:
type Parent struct {
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef,omitempty"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef,omitempty"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef,omitempty"<TICK>
}
   we need to generate the following ${PROTO_RESOURCE}Parent struct:
type ${PROTO_RESOURCE}Parent struct {
	ProjectID      string
	OrganizationID string
	FolderID       string
	Location       string
}

Please update the ${PROTO_RESOURCE}Parent's String() method to return the correct string.
Example String() method returns are:
 - "projects/{{project}}/locations/{{location}}"
 - "folders/{{folder}}/locations/{{location}}"
 - "organizations/{{organization}}"
 - "projects/{{project}}"
There may be other patterns, please inspect the ${PROTO_RESOURCE}Parent and the <TICK>message ${PROTO_RESOURCE}<TICK> to determine the correct pattern.

Please update the Parse${PROTO_RESOURCE}External method to parse the ${PROTO_RESOURCE}Parent from a string.

Please update the ${IDENTITY_FILE} file with all the changes.
If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the ${PROTO_RESOURCE}Parent struct stating that no changes were needed.


Contents of ${IDENTITY_FILE}:
${IDENTITY_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func adjustIdentityParent(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	identityContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, identityPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read identity file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(ADJUST_IDENTITY_PARENT, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE_CONTENTS}", string(identityContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Adjust identity parent",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	_, err = executeCommand(opts, cfg)
	return []string{identityPath}, err
}

const ADJUST_IDENTITY_PARENT_NEW_FUNCTION string = `I want you to update the New${PROTO_RESOURCE}Identity method in the ${IDENTITY_FILE} file.

Main Objectives:
1. Modify the New${PROTO_RESOURCE}Identity method in ${IDENTITY_FILE}.
2. Please do not modify the ${RESOURCE_TYPES_FILES} file.
4. Please update the ${IDENTITY_FILE} file with the modified method New${PROTO_RESOURCE}Identity.

Rules for modifying the New${PROTO_RESOURCE}Identity method:
1. The New${PROTO_RESOURCE}Identity method should be updated to resolve the fields of the ${PROTO_RESOURCE}Parent.
2. The fields of the ${PROTO_RESOURCE}Parent are resolved from the Parent fields in the ${RESOURCE_TYPES_FILES} file.
3. An example resolution of the ${PROTO_RESOURCE}Parent fields is:
	// Get Parent
	projectRef, err := refsv1beta1.ResolveProject(ctx, reader, obj.GetNamespace(), obj.Spec.ProjectRef)
	if err != nil {
		return nil, err
	}
4. Make sure that all fields of the ${PROTO_RESOURCE}Parent are resolved.
5. Make sure all the fields of ${PROTO_RESOURCE}Parent are set in the return value.
6. Please do not modify the ${RESOURCE_TYPES_FILES} file.
7.  Please update the ${IDENTITY_FILE} file with the modified method New${PROTO_RESOURCE}Identity.

If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the New${PROTO_RESOURCE}Identity method stating that no changes were needed.

Contents of ${IDENTITY_FILE}:
${IDENTITY_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

`

func adjustIdentityParentNewFunction(ctx context.Context, opts *RunnerOptions, branch Branch) ([]string, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	identityContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, identityPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read identity file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(ADJUST_IDENTITY_PARENT_NEW_FUNCTION, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE_CONTENTS}", string(identityContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Adjust identity parent new function",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	_, err = executeCommand(opts, cfg)
	return []string{identityPath}, err
}
